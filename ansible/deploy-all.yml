---
- name: DevOps Pets Infrastructure Deployment
  hosts: localhost
  gather_facts: yes
  become: no
  vars:
    project_root: "{{ playbook_dir | dirname | realpath }}"
    k8s_path: "{{ project_root }}/k8s"
    cluster_name: "devops-pets"
    namespace: "devops-pets"
  
  tasks:
    # Install missing tools using proper Ansible tasks
    - name: Include Kind installation
      include_tasks: tasks/install-kind.yml
      when: ansible_os_family == "Debian"

    - name: Include Kubectl installation
      include_tasks: tasks/install-kubectl.yml
      when: ansible_os_family == "Debian"

    - name: Include Docker installation
      include_tasks: tasks/install-docker.yml
      when: ansible_os_family == "Debian"

    # Check if required tools are available (after installation)
    - name: Check if Docker is available
      shell: |
        export PATH="/usr/local/bin:$PATH"
        docker --version
      register: docker_check
      failed_when: false
      changed_when: false

    - name: Check if Kind is available
      shell: |
        export PATH="/usr/local/bin:$PATH"
        kind version
      register: kind_check
      failed_when: false
      changed_when: false

    - name: Check if Kubectl is available
      shell: |
        export PATH="/usr/local/bin:$PATH"
        kubectl version --client --short
      register: kubectl_check
      failed_when: false
      changed_when: false

    - name: Check if Curl is available
      shell: |
        export PATH="/usr/local/bin:$PATH"
        curl --version
      register: curl_check
      failed_when: false
      changed_when: false

    - name: Check if Unzip is available
      shell: |
        export PATH="/usr/local/bin:$PATH"
        unzip -v
      register: unzip_check
      failed_when: false
      changed_when: false

    - name: Display tools status
      debug:
        msg: |
          === TOOLS STATUS ===
          Docker: {{ '✓ Available' if docker_check.rc == 0 else '✗ Missing' }}
          Kind: {{ '✓ Available' if kind_check.rc == 0 else '✗ Missing' }}
          Kubectl: {{ '✓ Available' if kubectl_check.rc == 0 else '✗ Missing' }}
          Curl: {{ '✓ Available' if curl_check.rc == 0 else '✗ Missing' }}
          Unzip: {{ '✓ Available' if unzip_check.rc == 0 else '✗ Missing' }}

    - name: Fail if required tools are missing
      fail:
        msg: |
          Missing required tools. Please install them manually:
          Docker: https://docs.docker.com/get-docker/
          Kind: https://kind.sigs.k8s.io/docs/user/quick-start/#installation
          Kubectl: https://kubernetes.io/docs/tasks/tools/install-kubectl/
      when: docker_check.rc != 0 or kind_check.rc != 0 or kubectl_check.rc != 0 or curl_check.rc != 0 or unzip_check.rc != 0

    - name: Display successful tools check
      debug:
        msg: |
          === SUCCESS ===
          All required tools are available!
          Docker: {{ docker_check.stdout }}
          Kind: {{ kind_check.stdout }}
          Kubectl: {{ kubectl_check.stdout }}
      when: docker_check.rc == 0 and kind_check.rc == 0 and kubectl_check.rc == 0 and curl_check.rc == 0 and unzip_check.rc == 0

    - name: Display deployment start
      debug:
        msg: |
          DEVOPS PETS INFRASTRUCTURE DEPLOYMENT
          =====================================
          Following exact order with comprehensive wait till ready:
          1. Harsh cleanup (preserve jenkins_home only)
          2. Create Kind cluster
          3. Create namespace with Jenkins home directory and PV/PVC templates
          4. Build and load custom images (Jenkins, PostgreSQL, MailHog)
          5. Apply manifests
          6. Wait for each service deployment to be available
          7. Wait for each pod to be fully ready
          8. Wait for ALL pods to be ready and verify status
          9. Final verification with detailed status
          10. Port forward only when everything is ready
          
          All services (Jenkins, PostgreSQL, MailHog) run in same namespace
          Jenkins will have cluster access for future frontend/backend management
          
          Cleanup preserves: jenkins_home only
          Cleanup refreshes: images, cluster, port forwarding, all resources
          
          WAITING STRATEGY: Comprehensive verification ensures all pods are fully operational before proceeding

    # STEP 1: HARSH CLEANUP (preserve jenkins_home only)
    - name: Harsh cleanup - preserve jenkins_home only
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 1: HARSH CLEANUP ==="
        echo "PRESERVING: jenkins_home only"
        echo "REFRESHING: images, cluster, port forwarding"
        
        # Show current state
        echo "Current clusters:"
        kind get clusters 2>/dev/null || echo "No kind clusters found"
        echo "Current namespaces:"
        kubectl get namespaces 2>/dev/null || echo "kubectl not available"
        
        # Force kill ALL kubectl port-forward processes
        echo "Killing ALL kubectl port-forward processes..."
        pkill -f "kubectl port-forward" 2>/dev/null || true
        sleep 2
        
        # Force delete devops-pets namespace and ALL resources
        echo "Force deleting devops-pets namespace and ALL resources..."
        if command -v kubectl >/dev/null 2>&1; then
          # Delete ALL resources in namespace first
          kubectl delete all --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete pvc --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete pv --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete deployment --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete service --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete configmap --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete secret --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete ingress --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete daemonset --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete statefulset --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete job --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete cronjob --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          
          # Delete namespace with force
          kubectl delete namespace {{ namespace }} --force --grace-period=0 2>/dev/null || true
          
          # Wait and try again if still exists
          sleep 10
          if kubectl get namespace {{ namespace }} 2>/dev/null; then
            echo "Namespace still exists, trying more aggressive deletion..."
            kubectl patch namespace {{ namespace }} -p '{"metadata":{"finalizers":[]}}' --type=merge 2>/dev/null || true
            kubectl delete namespace {{ namespace }} --force --grace-period=0 2>/dev/null || true
            sleep 5
          fi
        fi
        
        # Remove ALL devops-pets images (force refresh)
        echo "Removing ALL devops-pets images for fresh build..."
        docker images | grep devops-pets | awk '{print $3}' | xargs -r docker rmi -f 2>/dev/null || true
        
        # Delete devops-pets cluster (force refresh)
        echo "Deleting devops-pets cluster for fresh creation..."
        if command -v kind >/dev/null 2>&1; then
          kind delete cluster --name {{ cluster_name }} 2>/dev/null || true
        fi
        
        # Wait for everything to settle
        sleep 5
        
        # Show final state
        echo "Final clusters:"
        kind get clusters 2>/dev/null || echo "No kind clusters found"
        echo "Final namespaces:"
        kubectl get namespaces 2>/dev/null || echo "kubectl not available"
        
        echo "OK! HARSH CLEANUP completed (jenkins_home preserved, everything else refreshed)"
      register: cleanup_result
      failed_when: false

    # STEP 2: CREATE KIND CLUSTER
    - name: Create jenkins_home directory
      file:
        path: "{{ project_root }}/jenkins_home"
        state: directory
        mode: '0755'

    - name: Create Kind cluster
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 2: CREATING KIND CLUSTER ==="
        cd {{ project_root }}
        kind create cluster --name {{ cluster_name }} --config kind-config.yaml
        echo "OK! Kind cluster created"
        
        echo "Verifying cluster..."
        kind get clusters
        kubectl cluster-info
      register: cluster_create

    # STEP 3: CREATE NAMESPACE
    - name: Create namespace
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 3: CREATING NAMESPACE ==="
        kubectl create namespace {{ namespace }}
        echo "OK! Namespace created"
        
        echo "Verifying namespace..."
        kubectl get namespaces | grep {{ namespace }}
      register: namespace_create

    - name: Setup Jenkins home directory in namespace
      file:
        path: "{{ project_root }}/jenkins_home"
        state: directory
        mode: '0755'
      register: jenkins_home_setup

    - name: Create Jenkins home PersistentVolume
      template:
        src: jenkins-home-pv.yaml.j2
        dest: "{{ project_root }}/jenkins_home_pv.yaml"
      register: jenkins_pv_template

    - name: Create Jenkins home PersistentVolumeClaim
      template:
        src: jenkins-home-pvc.yaml.j2
        dest: "{{ project_root }}/jenkins_home_pvc.yaml"
      register: jenkins_pvc_template

    - name: Apply Jenkins home PV and PVC
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 3.2: APPLYING JENKINS HOME PV/PVC ==="
        cd {{ project_root }}
        
        # Apply the PV and PVC
        kubectl apply -f jenkins_home_pv.yaml
        kubectl apply -f jenkins_home_pvc.yaml
        
        echo "OK! Jenkins home PV/PVC applied"
      register: jenkins_pv_apply

    # STEP 4: BUILD AND LOAD IMAGES
    - name: Build Jenkins image
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 4: BUILDING JENKINS IMAGE ==="
        cd {{ project_root }}
        docker build -t devops-pets-jenkins:latest {{ k8s_path }}/jenkins/
        echo "OK! Jenkins image built"
        
        echo "Verifying Jenkins image..."
        docker images | grep devops-pets-jenkins
      register: jenkins_build

    - name: Load Jenkins image to Kind cluster
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 4.1: LOADING JENKINS IMAGE TO KIND CLUSTER ==="
        cd {{ project_root }}
        kind load docker-image devops-pets-jenkins:latest --name {{ cluster_name }}
        echo "OK! Jenkins image loaded"
        
        echo "Verifying loaded images..."
        docker exec {{ cluster_name }}-control-plane crictl images | grep devops-pets-jenkins
      register: jenkins_load

    - name: Build PostgreSQL image
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 4.2: BUILDING POSTGRESQL IMAGE ==="
        cd {{ project_root }}
        docker build -t devops-pets-postgres:latest {{ k8s_path }}/postgres/
        echo "OK! PostgreSQL image built"
        
        echo "Verifying PostgreSQL image..."
        docker images | grep devops-pets-postgres
      register: postgres_build

    - name: Load PostgreSQL image to Kind cluster
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 4.3: LOADING POSTGRESQL IMAGE TO KIND CLUSTER ==="
        cd {{ project_root }}
        kind load docker-image devops-pets-postgres:latest --name {{ cluster_name }}
        echo "OK! PostgreSQL image loaded"
        
        echo "Verifying loaded images..."
        docker exec {{ cluster_name }}-control-plane crictl images | grep devops-pets-postgres
      register: postgres_load

    - name: Build MailHog image
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 4.4: BUILDING MAILHOG IMAGE ==="
        cd {{ project_root }}
        docker build -t devops-pets-mailhog:latest {{ k8s_path }}/mailhog/
        echo "OK! MailHog image built"
        
        echo "Verifying MailHog image..."
        docker images | grep devops-pets-mailhog
      register: mailhog_build

    - name: Load MailHog image to Kind cluster
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 4.5: LOADING MAILHOG IMAGE TO KIND CLUSTER ==="
        cd {{ project_root }}
        kind load docker-image devops-pets-mailhog:latest --name {{ cluster_name }}
        echo "OK! MailHog image loaded"
        
        echo "Verifying loaded images..."
        docker exec {{ cluster_name }}-control-plane crictl images | grep devops-pets-mailhog
      register: mailhog_load

    # STEP 5: APPLY MANIFESTS
    - name: Apply PostgreSQL manifests
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 5: APPLYING POSTGRESQL MANIFESTS ==="
        cd {{ project_root }}
        kubectl apply -f {{ k8s_path }}/postgres/ -n {{ namespace }}
        echo "OK! PostgreSQL manifests applied"
      register: postgres_apply

    - name: Apply MailHog manifests
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 5.1: APPLYING MAILHOG MANIFESTS ==="
        cd {{ project_root }}
        kubectl apply -f {{ k8s_path }}/mailhog/ -n {{ namespace }}
        echo "OK! MailHog manifests applied"
      register: mailhog_apply

    - name: Apply Jenkins manifests
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 5.2: APPLYING JENKINS MANIFESTS ==="
        cd {{ project_root }}
        kubectl apply -f {{ k8s_path }}/jenkins/ -n {{ namespace }}
        echo "OK! Jenkins manifests applied"
      register: jenkins_apply

    # STEP 6: WAIT FOR SERVICES TO BE READY (using kubectl wait like old script)
    - name: Wait for PostgreSQL to be ready
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 6: WAITING FOR POSTGRESQL TO BE READY ==="
        echo "Waiting for PostgreSQL deployment to be ready..."
        
        kubectl wait --for=condition=available --timeout=300s deployment/postgres -n {{ namespace }}
        echo "OK! PostgreSQL deployment is ready!"
        
        echo "Waiting for PostgreSQL pod to be fully ready..."
        kubectl wait --for=condition=ready --timeout=300s pod -l app=postgres -n {{ namespace }}
        echo "OK! PostgreSQL pod is fully ready!"
        
        echo "Verifying PostgreSQL pod..."
        kubectl get pods -n {{ namespace }} | grep postgres
      args:
        chdir: "{{ project_root }}"
      register: postgres_ready

    - name: Wait for MailHog to be ready
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 6.1: WAITING FOR MAILHOG TO BE READY ==="
        echo "Waiting for MailHog deployment to be ready..."
        
        kubectl wait --for=condition=available --timeout=300s deployment/mailhog -n {{ namespace }}
        echo "OK! MailHog deployment is ready!"
        
        echo "Waiting for MailHog pod to be fully ready..."
        kubectl wait --for=condition=ready --timeout=300s pod -l app=mailhog -n {{ namespace }}
        echo "OK! MailHog pod is fully ready!"
        
        echo "Verifying MailHog pod..."
        kubectl get pods -n {{ namespace }} | grep mailhog
      args:
        chdir: "{{ project_root }}"
      register: mailhog_ready

    - name: Wait for Jenkins to be ready
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 6.2: WAITING FOR JENKINS TO BE READY ==="
        echo "Waiting for Jenkins deployment to be ready..."
        
        kubectl wait --for=condition=available --timeout=300s deployment/jenkins -n {{ namespace }}
        echo "OK! Jenkins deployment is ready!"
        
        echo "Waiting for Jenkins pod to be fully ready..."
        kubectl wait --for=condition=ready --timeout=300s pod -l app=jenkins -n {{ namespace }}
        echo "OK! Jenkins pod is fully ready!"
        
        echo "Verifying Jenkins pod..."
        kubectl get pods -n {{ namespace }} | grep jenkins
      args:
        chdir: "{{ project_root }}"
      register: jenkins_ready

    # STEP 7: ADDITIONAL VERIFICATION AND WAITING
    - name: Wait for all pods to be ready
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 7: FINAL VERIFICATION - ALL PODS READY ==="
        echo "Waiting for ALL pods to be in Running state..."
        
        # Wait for all pods to be running
        kubectl wait --for=condition=ready --timeout=300s pod --all -n {{ namespace }}
        echo "OK! All pods are ready!"
        
        # Additional verification
        echo "Verifying all pods are running..."
        kubectl get pods -n {{ namespace }} -o wide
        
        # Check if any pods are not ready
        NOT_READY_PODS=$(kubectl get pods -n {{ namespace }} --no-headers | grep -v "Running\|Completed" | wc -l)
        if [ "$NOT_READY_PODS" -gt 0 ]; then
          echo "WARNING: Some pods are not ready:"
          kubectl get pods -n {{ namespace }} --no-headers | grep -v "Running\|Completed"
          exit 1
        else
          echo "SUCCESS: All pods are running!"
        fi
        
        # Wait a bit more for services to be fully operational
        echo "Waiting for services to be fully operational..."
        sleep 10
        
        echo "OK! All infrastructure services are fully ready!"
      args:
        chdir: "{{ project_root }}"
      register: all_pods_ready

    # STEP 8: FINAL VERIFICATION
    - name: Final verification
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 8: FINAL VERIFICATION ==="
        echo "All pods in {{ namespace }} namespace:"
        kubectl get pods -n {{ namespace }}
        
        echo "All services in {{ namespace }} namespace:"
        kubectl get services -n {{ namespace }}
        
        echo "All deployments in {{ namespace }} namespace:"
        kubectl get deployments -n {{ namespace }}
        
        echo "Pod status summary:"
        kubectl get pods -n {{ namespace }} -o custom-columns="NAME:.metadata.name,STATUS:.status.phase,READY:.status.containerStatuses[0].ready,RESTARTS:.status.containerStatuses[0].restartCount"
        
        echo "OK! All infrastructure services are deployed and ready!"
      args:
        chdir: "{{ project_root }}"
      register: final_verification

    # STEP 9: SETUP PORT FORWARDING (only at the end)
    - name: Setup port forwarding
      shell: |
        export PATH="/usr/local/bin:$PATH"
        echo "=== STEP 9: SETTING UP PORT FORWARDING ==="
        echo "Setting up port forwarding for Jenkins (8082) and MailHog (8025)..."
        
        # Kill any existing port forwarding
        pkill -f "kubectl port-forward" 2>/dev/null || true
        sleep 2
        
        # Start port forwarding in background using screen or tmux if available
        if command -v screen >/dev/null 2>&1; then
          echo "Using screen for port forwarding..."
          screen -dmS jenkins-pf bash -c "kubectl port-forward -n {{ namespace }} service/jenkins 8082:8080"
          screen -dmS mailhog-pf bash -c "kubectl port-forward -n {{ namespace }} service/mailhog 8025:8025"
        elif command -v tmux >/dev/null 2>&1; then
          echo "Using tmux for port forwarding..."
          tmux new-session -d -s jenkins-pf "kubectl port-forward -n {{ namespace }} service/jenkins 8082:8080"
          tmux new-session -d -s mailhog-pf "kubectl port-forward -n {{ namespace }} service/mailhog 8025:8025"
        else
          echo "Using nohup for port forwarding..."
          nohup kubectl port-forward -n {{ namespace }} service/jenkins 8082:8080 > /tmp/jenkins_pf.log 2>&1 &
          JENKINS_PF_PID=$!
          
          nohup kubectl port-forward -n {{ namespace }} service/mailhog 8025:8025 > /tmp/mailhog_pf.log 2>&1 &
          MAILHOG_PF_PID=$!
          
          # Save PIDs to files for later use
          echo $JENKINS_PF_PID > /tmp/jenkins_pf.pid
          echo $MAILHOG_PF_PID > /tmp/mailhog_pf.pid
        fi
        
        # Wait a moment for port forwarding to establish
        sleep 5
        
        # Check if port forwarding is working
        if curl -s http://localhost:8082 > /dev/null 2>&1; then
          echo "SUCCESS: Jenkins port forwarding is working"
        else
          echo "INFO: Jenkins port forwarding may take a moment to establish"
        fi
        
        if curl -s http://localhost:8025 > /dev/null 2>&1; then
          echo "SUCCESS: MailHog port forwarding is working"
        else
          echo "INFO: MailHog port forwarding may take a moment to establish"
        fi
        
        echo "OK! Port forwarding started!"
        echo "Jenkins: http://localhost:8082"
        echo "MailHog: http://localhost:8025"
        echo ""
        echo "To stop port forwarding, run:"
        echo "pkill -f 'kubectl port-forward'"
        echo "Or: screen -S jenkins-pf -X quit && screen -S mailhog-pf -X quit"
      args:
        chdir: "{{ project_root }}"
      register: port_forwarding
      ignore_errors: true

    # FINAL SUCCESS MESSAGE
    - name: Display final success message
      debug:
        msg: |
          ================================
          OK! DEVOPS PETS INFRASTRUCTURE DEPLOYMENT COMPLETED SUCCESSFULLY!
          ================================
          
          All infrastructure services are deployed and ready:
          - Jenkins: http://localhost:8082
          - MailHog: http://localhost:8025
          - PostgreSQL: Running in cluster
          
          ================================
          Useful commands:
          - Check services: kubectl get all -n {{ namespace }}
          - View logs: kubectl logs -n {{ namespace }}
          - Stop port forwarding: pkill -f 'kubectl port-forward'
          ================================ 