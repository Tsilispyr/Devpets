---
- name: DevOps Pets Infrastructure Deployment
  hosts: localhost
  gather_facts: no
  become: no
  vars:
    project_root: "{{ playbook_dir | realpath }}"
    k8s_path: "{{ project_root }}/k8s"
    cluster_name: "devops-pets"
    namespace: "devops-pets"
  
  tasks:
    - name: Display deployment start
      debug:
        msg: |
          DEVOPS PETS INFRASTRUCTURE DEPLOYMENT
          =====================================
          Following exact order with wait till ready:
          1. Harsh cleanup (preserve jenkins_home, PVCs and tools)
          2. Create Kind cluster
          3. Create namespace
          4. Deploy PostgreSQL (with wait)
          5. Deploy MailHog (with wait)
          6. Build and deploy Jenkins (with wait)
          7. Port forward only at the end

    # STEP 1: HARSH CLEANUP (preserve jenkins_home, PVCs and tools)
    - name: Harsh cleanup - preserve jenkins_home, PVCs and tools
      shell: |
        echo "=== STEP 1: HARSH CLEANUP ==="
        echo "PRESERVING: jenkins_home, PVCs and system tools"
        
        # Show current state
        echo "Current clusters:"
        kind get clusters 2>/dev/null || echo "No kind clusters found"
        echo "Current namespaces:"
        kubectl get namespaces 2>/dev/null || echo "kubectl not available"
        
        # Force kill kubectl port-forward processes only
        echo "Killing kubectl port-forward processes..."
        pkill -f "kubectl port-forward" 2>/dev/null || true
        
        # Stop and remove devops-pets containers
        echo "Stopping and removing devops-pets containers..."
        docker ps -a | grep devops-pets | awk '{print $1}' | xargs -r docker stop 2>/dev/null || true
        docker ps -a | grep devops-pets | awk '{print $1}' | xargs -r docker rm 2>/dev/null || true
        
        # Remove devops-pets images
        echo "Removing devops-pets images..."
        docker images | grep devops-pets | awk '{print $3}' | xargs -r docker rmi -f 2>/dev/null || true
        
        # Delete devops-pets namespace only (PVCs will be preserved)
        echo "Deleting devops-pets namespace..."
        if command -v kubectl >/dev/null 2>&1; then
          kubectl delete namespace {{ namespace }} --force --grace-period=0 --timeout=10s 2>/dev/null || true
        fi
        
        # Delete devops-pets cluster only
        echo "Deleting devops-pets cluster..."
        if command -v kind >/dev/null 2>&1; then
          kind delete cluster --name {{ cluster_name }} 2>/dev/null || true
        fi
        
        # Clean up any remaining containers
        echo "Cleaning up any remaining containers..."
        docker ps -a | grep -E "(jenkins|postgres|mailhog)" | awk '{print $1}' | xargs -r docker stop 2>/dev/null || true
        docker ps -a | grep -E "(jenkins|postgres|mailhog)" | awk '{print $1}' | xargs -r docker rm 2>/dev/null || true
        
        # Wait for everything to settle
        sleep 3
        
        # Show final state
        echo "Final clusters:"
        kind get clusters 2>/dev/null || echo "No kind clusters found"
        echo "Final namespaces:"
        kubectl get namespaces 2>/dev/null || echo "kubectl not available"
        
        echo "OK! HARSH CLEANUP completed (jenkins_home, PVCs and tools preserved)"
      args:
        chdir: "{{ project_root }}"
      register: cleanup_result
      failed_when: false

    # STEP 2: CREATE KIND CLUSTER
    - name: Create Kind cluster
      shell: |
        echo "=== STEP 2: CREATING KIND CLUSTER ==="
        kind create cluster --name {{ cluster_name }} --config kind-config.yaml
        echo "OK! Kind cluster created"
        
        echo "Verifying cluster..."
        kind get clusters
        kubectl cluster-info
      args:
        chdir: "{{ project_root }}"
      register: cluster_create

    - name: Create jenkins_home directory
      file:
        path: "{{ project_root }}/jenkins_home"
        state: directory
        mode: '0755'

    # STEP 3: CREATE NAMESPACE
    - name: Create namespace
      shell: |
        echo "=== STEP 3: CREATING NAMESPACE ==="
        kubectl create namespace {{ namespace }}
        echo "OK! Namespace created"
        
        echo "Verifying namespace..."
        kubectl get namespaces | grep {{ namespace }}
      args:
        chdir: "{{ project_root }}"
      register: namespace_create

    # STEP 4: DEPLOY POSTGRESQL
    - name: Apply PostgreSQL manifests
      shell: |
        echo "=== STEP 4: DEPLOYING POSTGRESQL ==="
        kubectl apply -f {{ k8s_path }}/postgres/ -n {{ namespace }}
        echo "OK! PostgreSQL manifests applied"
      args:
        chdir: "{{ project_root }}"
      register: postgres_apply

    - name: Wait for PostgreSQL to be ready
      shell: |
        echo "=== STEP 4.1: WAITING FOR POSTGRESQL TO BE READY ==="
        echo "Waiting for PostgreSQL deployment to be ready..."
        
        max_attempts=30
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          if kubectl get deployment postgres -n {{ namespace }} --no-headers 2>/dev/null | grep -q "1/1"; then
            echo "OK! PostgreSQL deployment is ready!"
            break
          fi
          
          echo "Attempt $attempt/$max_attempts - waiting 10 seconds..."
          sleep 10
          attempt=$((attempt + 1))
        done
        
        if [ $attempt -gt $max_attempts ]; then
          echo "ERR! PostgreSQL deployment failed to become ready after $max_attempts attempts"
          exit 1
        fi
        
        echo "Verifying PostgreSQL pod..."
        kubectl get pods -n {{ namespace }} | grep postgres
      args:
        chdir: "{{ project_root }}"
      register: postgres_ready

    # STEP 5: DEPLOY MAILHOG
    - name: Apply MailHog manifests
      shell: |
        echo "=== STEP 5: DEPLOYING MAILHOG ==="
        kubectl apply -f {{ k8s_path }}/mailhog/ -n {{ namespace }}
        echo "OK! MailHog manifests applied"
      args:
        chdir: "{{ project_root }}"
      register: mailhog_apply

    - name: Wait for MailHog to be ready
      shell: |
        echo "=== STEP 5.1: WAITING FOR MAILHOG TO BE READY ==="
        echo "Waiting for MailHog deployment to be ready..."
        
        max_attempts=30
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          if kubectl get deployment mailhog -n {{ namespace }} --no-headers 2>/dev/null | grep -q "1/1"; then
            echo "OK! MailHog deployment is ready!"
            break
          fi
          
          echo "Attempt $attempt/$max_attempts - waiting 10 seconds..."
          sleep 10
          attempt=$((attempt + 1))
        done
        
        if [ $attempt -gt $max_attempts ]; then
          echo "ERR! MailHog deployment failed to become ready after $max_attempts attempts"
          exit 1
        fi
        
        echo "Verifying MailHog pod..."
        kubectl get pods -n {{ namespace }} | grep mailhog
      args:
        chdir: "{{ project_root }}"
      register: mailhog_ready

    # STEP 6: BUILD AND DEPLOY JENKINS
    - name: Build Jenkins image
      shell: |
        echo "=== STEP 6: BUILDING JENKINS IMAGE ==="
        docker build -t devops-pets-jenkins:latest {{ k8s_path }}/jenkins/
        echo "OK! Jenkins image built"
        
        echo "Verifying Jenkins image..."
        docker images | grep devops-pets-jenkins
      args:
        chdir: "{{ project_root }}"
      register: jenkins_build

    - name: Load Jenkins image to Kind cluster
      shell: |
        echo "=== STEP 6.1: LOADING JENKINS IMAGE TO KIND CLUSTER ==="
        kind load docker-image devops-pets-jenkins:latest --name {{ cluster_name }}
        echo "OK! Jenkins image loaded"
        
        echo "Verifying loaded images..."
        docker exec {{ cluster_name }}-control-plane crictl images | grep devops-pets-jenkins
      args:
        chdir: "{{ project_root }}"
      register: jenkins_load

    - name: Apply Jenkins manifests
      shell: |
        echo "=== STEP 6.2: DEPLOYING JENKINS ==="
        kubectl apply -f {{ k8s_path }}/jenkins/ -n {{ namespace }}
        echo "OK! Jenkins manifests applied"
      args:
        chdir: "{{ project_root }}"
      register: jenkins_apply

    - name: Wait for Jenkins to be ready
      shell: |
        echo "=== STEP 6.3: WAITING FOR JENKINS TO BE READY ==="
        echo "Waiting for Jenkins deployment to be ready..."
        
        max_attempts=30
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          if kubectl get deployment jenkins -n {{ namespace }} --no-headers 2>/dev/null | grep -q "1/1"; then
            echo "OK! Jenkins deployment is ready!"
            break
          fi
          
          echo "Attempt $attempt/$max_attempts - waiting 10 seconds..."
          sleep 10
          attempt=$((attempt + 1))
        done
        
        if [ $attempt -gt $max_attempts ]; then
          echo "ERR! Jenkins deployment failed to become ready after $max_attempts attempts"
          exit 1
        fi
        
        echo "Verifying Jenkins pod..."
        kubectl get pods -n {{ namespace }} | grep jenkins
      args:
        chdir: "{{ project_root }}"
      register: jenkins_ready

    # STEP 7: FINAL VERIFICATION
    - name: Final verification
      shell: |
        echo "=== STEP 7: FINAL VERIFICATION ==="
        echo "All pods in {{ namespace }} namespace:"
        kubectl get pods -n {{ namespace }}
        
        echo "All services in {{ namespace }} namespace:"
        kubectl get services -n {{ namespace }}
        
        echo "All deployments in {{ namespace }} namespace:"
        kubectl get deployments -n {{ namespace }}
        
        echo "OK! All infrastructure services are deployed and ready!"
      args:
        chdir: "{{ project_root }}"
      register: final_verification

    # STEP 8: SETUP PORT FORWARDING (only at the end)
    - name: Setup port forwarding
      shell: |
        echo "=== STEP 8: SETTING UP PORT FORWARDING ==="
        echo "Setting up port forwarding for Jenkins (8082) and MailHog (8025)..."
        
        # Kill any existing port forwarding
        pkill -f "kubectl port-forward" 2>/dev/null || true
        
        # Start port forwarding in background
        kubectl port-forward -n {{ namespace }} service/jenkins 8082:8080 &
        JENKINS_PF_PID=$!
        
        kubectl port-forward -n {{ namespace }} service/mailhog 8025:8025 &
        MAILHOG_PF_PID=$!
        
        # Wait a moment for port forwarding to establish
        sleep 5
        
        echo "OK! Port forwarding started!"
        echo "Jenkins: http://localhost:8082"
        echo "MailHog: http://localhost:8025"
        echo ""
        echo "To stop port forwarding, run:"
        echo "kill $JENKINS_PF_PID $MAILHOG_PF_PID"
      args:
        chdir: "{{ project_root }}"
      register: port_forwarding

    # FINAL SUCCESS MESSAGE
    - name: Display final success message
      debug:
        msg: |
          ================================
          OK! DEVOPS PETS INFRASTRUCTURE DEPLOYMENT COMPLETED SUCCESSFULLY!
          ================================
          
          All infrastructure services are deployed and ready:
          - Jenkins: http://localhost:8082
          - MailHog: http://localhost:8025
          - PostgreSQL: Running in cluster
          
          ================================
          Useful commands:
          - Check services: kubectl get all -n {{ namespace }}
          - View logs: kubectl logs -n {{ namespace }}
          - Stop port forwarding: pkill -f 'kubectl port-forward'
          ================================ 