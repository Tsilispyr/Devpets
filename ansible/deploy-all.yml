---
- name: DevOps Pets Infrastructure Deployment
  hosts: localhost
  gather_facts: yes
  become: no
  vars:
    project_root: "{{ playbook_dir | dirname | realpath }}"
    k8s_path: "{{ project_root }}/k8s"
    cluster_name: "devops-pets"
    namespace: "devops-pets"
  
  tasks:
    # Check if required tools are available (skip installation if no sudo)
    - name: Check if required tools are available
      shell: |
        echo "=== CHECKING REQUIRED TOOLS ==="
        
        MISSING_TOOLS=()
        
        if ! command -v docker >/dev/null 2>&1; then
          MISSING_TOOLS+=("docker")
        fi
        
        if ! command -v kind >/dev/null 2>&1; then
          MISSING_TOOLS+=("kind")
        fi
        
        if ! command -v kubectl >/dev/null 2>&1; then
          MISSING_TOOLS+=("kubectl")
        fi
        
        if ! command -v curl >/dev/null 2>&1; then
          MISSING_TOOLS+=("curl")
        fi
        
        if ! command -v unzip >/dev/null 2>&1; then
          MISSING_TOOLS+=("unzip")
        fi
        
        if [ ${#MISSING_TOOLS[@]} -ne 0 ]; then
          echo "ERROR: Missing tools: ${MISSING_TOOLS[*]}"
          echo "Please install the missing tools manually:"
          echo "Docker: https://docs.docker.com/get-docker/"
          echo "Kind: https://kind.sigs.k8s.io/docs/user/quick-start/#installation"
          echo "Kubectl: https://kubernetes.io/docs/tasks/tools/install-kubectl/"
          exit 1
        else
          echo "SUCCESS: All required tools are available"
          echo "Docker version: $(docker --version)"
          echo "Kind version: $(kind version)"
          echo "Kubectl version: $(kubectl version --client --short)"
        fi
      register: tools_check
      failed_when: false

    - name: Display deployment start
      debug:
        msg: |
          DEVOPS PETS INFRASTRUCTURE DEPLOYMENT
          =====================================
          Following exact order with wait till ready:
          1. Harsh cleanup (preserve jenkins_home, docker tools, PVs)
          2. Create Kind cluster
          3. Create namespace with Jenkins home directory and PV/PVC templates
          4. Build and load custom images (Jenkins, PostgreSQL, MailHog)
          5. Apply manifests
          6. Wait till ready for each service (using kubectl wait)
          7. Port forward only at the end
          
          All services (Jenkins, PostgreSQL, MailHog) run in same namespace
          Jenkins will have cluster access for future frontend/backend management
          
          Cleanup preserves: jenkins_home, docker tools, PVs, other images/containers
          Cleanup removes: devops-pets images only

    # STEP 1: HARSH CLEANUP (preserve jenkins_home, docker tools, PVs)
    - name: Harsh cleanup - preserve jenkins_home, docker tools, PVs
      shell: |
        echo "=== STEP 1: HARSH CLEANUP ==="
        echo "PRESERVING: jenkins_home, docker tools, PVs and system tools"
        
        # Show current state
        echo "Current clusters:"
        kind get clusters 2>/dev/null || echo "No kind clusters found"
        echo "Current namespaces:"
        kubectl get namespaces 2>/dev/null || echo "kubectl not available"
        
        # Force kill kubectl port-forward processes only
        echo "Killing kubectl port-forward processes..."
        pkill -f "kubectl port-forward" 2>/dev/null || true
        
        # More aggressive namespace deletion
        echo "Force deleting devops-pets namespace and all resources..."
        if command -v kubectl >/dev/null 2>&1; then
          # Delete all resources in namespace first
          kubectl delete all --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete pvc --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete pv --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete deployment --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete service --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete configmap --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          kubectl delete secret --all -n {{ namespace }} --force --grace-period=0 2>/dev/null || true
          
          # Delete namespace with force
          kubectl delete namespace {{ namespace }} --force --grace-period=0 2>/dev/null || true
          
          # Wait and try again if still exists
          sleep 10
          if kubectl get namespace {{ namespace }} 2>/dev/null; then
            echo "Namespace still exists, trying more aggressive deletion..."
            kubectl patch namespace {{ namespace }} -p '{"metadata":{"finalizers":[]}}' --type=merge 2>/dev/null || true
            kubectl delete namespace {{ namespace }} --force --grace-period=0 2>/dev/null || true
            sleep 5
          fi
        fi
        
        # Remove ONLY devops-pets images (preserve all other images and containers)
        echo "Removing devops-pets images only..."
        docker images | grep devops-pets | awk '{print $3}' | xargs -r docker rmi -f 2>/dev/null || true
        
        # Delete devops-pets cluster only
        echo "Deleting devops-pets cluster..."
        if command -v kind >/dev/null 2>&1; then
          kind delete cluster --name {{ cluster_name }} 2>/dev/null || true
        fi
        
        # Wait for everything to settle
        sleep 5
        
        # Show final state
        echo "Final clusters:"
        kind get clusters 2>/dev/null || echo "No kind clusters found"
        echo "Final namespaces:"
        kubectl get namespaces 2>/dev/null || echo "kubectl not available"
        
        echo "OK! HARSH CLEANUP completed (jenkins_home, docker tools, PVs preserved)"
      register: cleanup_result
      failed_when: false

    # STEP 2: CREATE KIND CLUSTER
    - name: Create jenkins_home directory
      file:
        path: "{{ project_root }}/jenkins_home"
        state: directory
        mode: '0755'

    - name: Create Kind cluster
      shell: |
        echo "=== STEP 2: CREATING KIND CLUSTER ==="
        cd {{ project_root }}
        kind create cluster --name {{ cluster_name }} --config kind-config.yaml
        echo "OK! Kind cluster created"
        
        echo "Verifying cluster..."
        kind get clusters
        kubectl cluster-info
      register: cluster_create

    # STEP 3: CREATE NAMESPACE
    - name: Create namespace
      shell: |
        echo "=== STEP 3: CREATING NAMESPACE ==="
        kubectl create namespace {{ namespace }}
        echo "OK! Namespace created"
        
        echo "Verifying namespace..."
        kubectl get namespaces | grep {{ namespace }}
      register: namespace_create

    - name: Setup Jenkins home directory in namespace
      file:
        path: "{{ project_root }}/jenkins_home"
        state: directory
        mode: '0755'
      register: jenkins_home_setup

    - name: Create Jenkins home PersistentVolume
      template:
        src: jenkins-home-pv.yaml.j2
        dest: "{{ project_root }}/jenkins_home_pv.yaml"
      register: jenkins_pv_template

    - name: Create Jenkins home PersistentVolumeClaim
      template:
        src: jenkins-home-pvc.yaml.j2
        dest: "{{ project_root }}/jenkins_home_pvc.yaml"
      register: jenkins_pvc_template

    - name: Apply Jenkins home PV and PVC
      shell: |
        echo "=== STEP 3.2: APPLYING JENKINS HOME PV/PVC ==="
        cd {{ project_root }}
        
        # Apply the PV and PVC
        kubectl apply -f jenkins_home_pv.yaml
        kubectl apply -f jenkins_home_pvc.yaml
        
        echo "OK! Jenkins home PV/PVC applied"
      register: jenkins_pv_apply

    # STEP 4: BUILD AND LOAD IMAGES
    - name: Build Jenkins image
      shell: |
        echo "=== STEP 4: BUILDING JENKINS IMAGE ==="
        cd {{ project_root }}
        docker build -t devops-pets-jenkins:latest {{ k8s_path }}/jenkins/
        echo "OK! Jenkins image built"
        
        echo "Verifying Jenkins image..."
        docker images | grep devops-pets-jenkins
      register: jenkins_build

    - name: Load Jenkins image to Kind cluster
      shell: |
        echo "=== STEP 4.1: LOADING JENKINS IMAGE TO KIND CLUSTER ==="
        cd {{ project_root }}
        kind load docker-image devops-pets-jenkins:latest --name {{ cluster_name }}
        echo "OK! Jenkins image loaded"
        
        echo "Verifying loaded images..."
        docker exec {{ cluster_name }}-control-plane crictl images | grep devops-pets-jenkins
      register: jenkins_load

    - name: Build PostgreSQL image
      shell: |
        echo "=== STEP 4.2: BUILDING POSTGRESQL IMAGE ==="
        cd {{ project_root }}
        docker build -t devops-pets-postgres:latest {{ k8s_path }}/postgres/
        echo "OK! PostgreSQL image built"
        
        echo "Verifying PostgreSQL image..."
        docker images | grep devops-pets-postgres
      register: postgres_build

    - name: Load PostgreSQL image to Kind cluster
      shell: |
        echo "=== STEP 4.3: LOADING POSTGRESQL IMAGE TO KIND CLUSTER ==="
        cd {{ project_root }}
        kind load docker-image devops-pets-postgres:latest --name {{ cluster_name }}
        echo "OK! PostgreSQL image loaded"
        
        echo "Verifying loaded images..."
        docker exec {{ cluster_name }}-control-plane crictl images | grep devops-pets-postgres
      register: postgres_load

    - name: Build MailHog image
      shell: |
        echo "=== STEP 4.4: BUILDING MAILHOG IMAGE ==="
        cd {{ project_root }}
        docker build -t devops-pets-mailhog:latest {{ k8s_path }}/mailhog/
        echo "OK! MailHog image built"
        
        echo "Verifying MailHog image..."
        docker images | grep devops-pets-mailhog
      register: mailhog_build

    - name: Load MailHog image to Kind cluster
      shell: |
        echo "=== STEP 4.5: LOADING MAILHOG IMAGE TO KIND CLUSTER ==="
        cd {{ project_root }}
        kind load docker-image devops-pets-mailhog:latest --name {{ cluster_name }}
        echo "OK! MailHog image loaded"
        
        echo "Verifying loaded images..."
        docker exec {{ cluster_name }}-control-plane crictl images | grep devops-pets-mailhog
      register: mailhog_load

    # STEP 5: APPLY MANIFESTS
    - name: Apply PostgreSQL manifests
      shell: |
        echo "=== STEP 5: APPLYING POSTGRESQL MANIFESTS ==="
        cd {{ project_root }}
        kubectl apply -f {{ k8s_path }}/postgres/ -n {{ namespace }}
        echo "OK! PostgreSQL manifests applied"
      register: postgres_apply

    - name: Apply MailHog manifests
      shell: |
        echo "=== STEP 5.1: APPLYING MAILHOG MANIFESTS ==="
        cd {{ project_root }}
        kubectl apply -f {{ k8s_path }}/mailhog/ -n {{ namespace }}
        echo "OK! MailHog manifests applied"
      register: mailhog_apply

    - name: Apply Jenkins manifests
      shell: |
        echo "=== STEP 5.2: APPLYING JENKINS MANIFESTS ==="
        cd {{ project_root }}
        kubectl apply -f {{ k8s_path }}/jenkins/ -n {{ namespace }}
        echo "OK! Jenkins manifests applied"
      register: jenkins_apply

    # STEP 6: WAIT FOR SERVICES TO BE READY (using kubectl wait like old script)
    - name: Wait for PostgreSQL to be ready
      shell: |
        echo "=== STEP 6: WAITING FOR POSTGRESQL TO BE READY ==="
        echo "Waiting for PostgreSQL deployment to be ready..."
        
        kubectl wait --for=condition=available --timeout=300s deployment/postgres -n {{ namespace }}
        echo "OK! PostgreSQL deployment is ready!"
        
        echo "Verifying PostgreSQL pod..."
        kubectl get pods -n {{ namespace }} | grep postgres
      args:
        chdir: "{{ project_root }}"
      register: postgres_ready

    - name: Wait for MailHog to be ready
      shell: |
        echo "=== STEP 6.1: WAITING FOR MAILHOG TO BE READY ==="
        echo "Waiting for MailHog deployment to be ready..."
        
        kubectl wait --for=condition=available --timeout=300s deployment/mailhog -n {{ namespace }}
        echo "OK! MailHog deployment is ready!"
        
        echo "Verifying MailHog pod..."
        kubectl get pods -n {{ namespace }} | grep mailhog
      args:
        chdir: "{{ project_root }}"
      register: mailhog_ready

    - name: Wait for Jenkins to be ready
      shell: |
        echo "=== STEP 6.2: WAITING FOR JENKINS TO BE READY ==="
        echo "Waiting for Jenkins deployment to be ready..."
        
        kubectl wait --for=condition=available --timeout=300s deployment/jenkins -n {{ namespace }}
        echo "OK! Jenkins deployment is ready!"
        
        echo "Verifying Jenkins pod..."
        kubectl get pods -n {{ namespace }} | grep jenkins
      args:
        chdir: "{{ project_root }}"
      register: jenkins_ready

    # STEP 7: FINAL VERIFICATION
    - name: Final verification
      shell: |
        echo "=== STEP 7: FINAL VERIFICATION ==="
        echo "All pods in {{ namespace }} namespace:"
        kubectl get pods -n {{ namespace }}
        
        echo "All services in {{ namespace }} namespace:"
        kubectl get services -n {{ namespace }}
        
        echo "All deployments in {{ namespace }} namespace:"
        kubectl get deployments -n {{ namespace }}
        
        echo "OK! All infrastructure services are deployed and ready!"
      args:
        chdir: "{{ project_root }}"
      register: final_verification

    # STEP 8: SETUP PORT FORWARDING (only at the end)
    - name: Setup port forwarding
      shell: |
        echo "=== STEP 8: SETTING UP PORT FORWARDING ==="
        echo "Setting up port forwarding for Jenkins (8082) and MailHog (8025)..."
        
        # Kill any existing port forwarding
        pkill -f "kubectl port-forward" 2>/dev/null || true
        sleep 2
        
        # Start port forwarding in background using screen or tmux if available
        if command -v screen >/dev/null 2>&1; then
          echo "Using screen for port forwarding..."
          screen -dmS jenkins-pf bash -c "kubectl port-forward -n {{ namespace }} service/jenkins 8082:8080"
          screen -dmS mailhog-pf bash -c "kubectl port-forward -n {{ namespace }} service/mailhog 8025:8025"
        elif command -v tmux >/dev/null 2>&1; then
          echo "Using tmux for port forwarding..."
          tmux new-session -d -s jenkins-pf "kubectl port-forward -n {{ namespace }} service/jenkins 8082:8080"
          tmux new-session -d -s mailhog-pf "kubectl port-forward -n {{ namespace }} service/mailhog 8025:8025"
        else
          echo "Using nohup for port forwarding..."
          nohup kubectl port-forward -n {{ namespace }} service/jenkins 8082:8080 > /tmp/jenkins_pf.log 2>&1 &
          JENKINS_PF_PID=$!
          
          nohup kubectl port-forward -n {{ namespace }} service/mailhog 8025:8025 > /tmp/mailhog_pf.log 2>&1 &
          MAILHOG_PF_PID=$!
          
          # Save PIDs to files for later use
          echo $JENKINS_PF_PID > /tmp/jenkins_pf.pid
          echo $MAILHOG_PF_PID > /tmp/mailhog_pf.pid
        fi
        
        # Wait a moment for port forwarding to establish
        sleep 5
        
        # Check if port forwarding is working
        if curl -s http://localhost:8082 > /dev/null 2>&1; then
          echo "SUCCESS: Jenkins port forwarding is working"
        else
          echo "INFO: Jenkins port forwarding may take a moment to establish"
        fi
        
        if curl -s http://localhost:8025 > /dev/null 2>&1; then
          echo "SUCCESS: MailHog port forwarding is working"
        else
          echo "INFO: MailHog port forwarding may take a moment to establish"
        fi
        
        echo "OK! Port forwarding started!"
        echo "Jenkins: http://localhost:8082"
        echo "MailHog: http://localhost:8025"
        echo ""
        echo "To stop port forwarding, run:"
        echo "pkill -f 'kubectl port-forward'"
        echo "Or: screen -S jenkins-pf -X quit && screen -S mailhog-pf -X quit"
      args:
        chdir: "{{ project_root }}"
      register: port_forwarding
      ignore_errors: true

    # FINAL SUCCESS MESSAGE
    - name: Display final success message
      debug:
        msg: |
          ================================
          OK! DEVOPS PETS INFRASTRUCTURE DEPLOYMENT COMPLETED SUCCESSFULLY!
          ================================
          
          All infrastructure services are deployed and ready:
          - Jenkins: http://localhost:8082
          - MailHog: http://localhost:8025
          - PostgreSQL: Running in cluster
          
          ================================
          Useful commands:
          - Check services: kubectl get all -n {{ namespace }}
          - View logs: kubectl logs -n {{ namespace }}
          - Stop port forwarding: pkill -f 'kubectl port-forward'
          ================================ 